-------------------------------------------------------------------------------
--
-- Script:	tsseg.sql
-- Purpose:	Display tablespace segments in different dimensions
--              ixora save/restore_s+ used for saving user environment
--
-- Copyright:	(c) FTC LLC
-- Author:	Velikikh Mikhail
--
-- Description:	This script display information about tablespace segments
--
-- Usage:       @tsseg.sql "<tablespace>" "{<owner>|owner=<owner regexp>|
--                segment_name=<segment regexp>|gby=<gby cols>|
--                partition_name=<partition regexp>|oby=<oby cols>|
--                segment_type=<segment_type regexp>}"
--
-- Change history:
--   Vers:   1.0.0.0
--     Auth: Velikikh M.
--     Date: 2013/10/21 09:40
--     Desc: Creation
--
-------------------------------------------------------------------------------
--DOCSTART
--
--tsseg.sql
------------
--
--Tablespace segments report.
--
--tsseg.sql {tablespace_name}
--  [
--    [<owner>] |
--    [,gby=<group by cols>] |
--    [,oby=<order by cols>] |
--    [,owner=<regexp>] |
--    [,partition_name=<regexp>] |
--    [,segment_name=<regexp>] |
--    [,segment_type=<regexp>] |
--    [,top=<row count>]
--  ]
--
--DOCEND

@save_sqlplus_settings.sql

set timing off

col 2 new_v 2 nopri

select '' "2" from dual where null^=null;

def ts="&1."
def input="&2."

@eva "&input." owner gby oby partition_name segment_name segment_type top

@evadef "&input." owner

set term off

col if_ts new_v if_ts nopri
col if_owner new_v if_owner nopri
col if_gby_gby new_v if_gby_gby nopri
col if_gby_lst new_v if_gby_lst nopri
col if_oby new_v if_oby nopri
col if_partition_name new_v if_partition_name nopri
col if_segment_name new_v if_segment_name nopri
col if_segment_type new_v if_segment_type nopri
col if_top new_v if_top nopri

select nvl2('&ts.', '', '--') if_ts,
       nvl2('&owner.', '', '--') if_owner,
       case
				 when '&gby.' is not null
				 then '&gby.'
				 when '&owner.' is not null and '&segment_name.' is not null
				 then
				   'owner, segment_name'
				 when '&owner.' is not null
				 then
				   'owner'
				 when '&segment_name.' is not null
				 then
				   'owner, segment_name'
				 else
					 '()'
			 end if_gby_gby,
       case
				 when '&gby.' is not null
				 then '&gby.'
				 when '&owner.' is not null and '&segment_name.' is not null
				 then
				   'owner, segment_name'
				 when '&owner.' is not null
				 then
				   'owner'
				 when '&segment_name.' is not null
				 then
				   'owner, segment_name'
				 else
					 '--'
			 end if_gby_lst,
       nvl2('&oby.', '&oby.', '1') if_oby,
			 nvl2('&partition_name.', '', '--') if_partition_name,
       nvl2('&segment_name.', '', '--') if_segment_name,
       nvl2('&segment_type.', '', '--') if_segment_type,
			 nvl2('&top.', 'rownum<=&top.', '1=1') if_top
  from dual
/

set term on
set echo off
set ver off

col blocks nopri
col blocksh hea BLOCKS
col bytes nopri
col bytesh hea BYTES
col extents nopri
col extentsh hea EXTENTS
col segment_name for a30

select *
  from (
       select &if_gby_lst.,
              sum(blocks) blocks,
       			 lpad(case when sum(blocks) < 1e5 then sum(blocks) || ' '
                        when sum(blocks) < 1e8 then round(sum(blocks)/1e3) || 'K'
                        when sum(blocks) < 1e11 then round(sum(blocks)/1e6) || 'M'
                        else round(sum(blocks) / 1e9) || 'G'
                   end, 6, ' '
              ) blocksh,
              sum(bytes) bytes,
       			 lpad(case when sum(bytes) < 1e5 then sum(bytes) || ' '
                        when sum(bytes) < 1e8 then round(sum(bytes)/1e3) || 'K'
                        when sum(bytes) < 1e11 then round(sum(bytes)/1e6) || 'M'
                        else round(sum(bytes) / 1e9) || 'G'
                   end, 6, ' '
              ) bytesh,
              sum(extents) extents,
       			 lpad(case when sum(extents) < 1e5 then sum(extents) || ' '
                        when sum(extents) < 1e8 then round(sum(extents)/1e3) || 'K'
                        when sum(extents) < 1e11 then round(sum(extents)/1e6) || 'M'
                        else round(sum(extents) / 1e9) || 'G'
                   end, 6, ' '
              ) extentsh
         from dba_segments
        where tablespace_name = '&ts.'
          &if_owner. and regexp_like(owner, '&owner.')
       	 &if_partition_name. and regexp_like( partition_name, '&partition_name.')
       	 &if_segment_name. and regexp_like( segment_name, '&segment_name.')
       	 &if_segment_type. and regexp_like( segment_type, '&segment_type.')
       	 and segment_name not like 'BIN$%'
        group by &if_gby_gby.
        order by &if_oby.)
 where &if_top.
/

undef input
undef ts
undef if_ts
undef owner
undef if_owner
undef gby
undef if_gby_gby
undef if_gby_lst
undef oby
undef if_oby

col segment_name cle

@restore_sqlplus_settings.sql
